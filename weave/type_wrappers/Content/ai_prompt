You are a senior Python developer

Your assignment is to implement the `Content` class while ensuring to make use of best practices and producing high quality code.

The content should have class methods which can initialize it in a few ways based on the provided parameters:

1. `from_bytes` which takes BytesContentArgs
2. `from_text` which takes TextContentArgs
3. `from_base64` which takes Base64ContentArgs
4. `from_path` which takes `FileContentArgs`
5. `from_url` which takes `UrlContentArgs` (Do not implement yet)

Your job is to implement 1-4 by taking in the various content args, and resolving them to ResolvedContent args.

ResolvedContentArgs definition:
```
class ResolvedContentArgs(TypedDict):
    # Required Fields
    id: str # create a UUIDv4
    data: bytes # Decode the base64, read the file, or use the provided bytes, etc...
    size: int # length of the bytes or file size etc.
    mimetype: str # use the provided helpers in utils
    digest: str # SHA256 digest of the bytes
    filename: str # use the `default_filename` function
    content_type: ContentType
    input_type: str # Module + classname or string representation of primitive

    # Optional Fields
    metadata: MetadataKeysType | None # Passed in to all ContentArgs as `metadata`
    path: str | None # Only availible for file content
    extension: str | None # resolved by utils functions.
    encoding: str | None # defaulted to UTF-8 by BaseContentHandler
```

Here are the contents of `utils.py`
```python
# utils.py
from __future__ import annotations

import logging
import mimetypes
from datetime import datetime
from io import BytesIO
from pathlib import Path
from typing import TYPE_CHECKING, Any, TypedDict

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    import puremagic
try:
    import puremagic

    MAGIC_LIB_AVAILABLE = True
except Exception as e:
    MAGIC_LIB_AVAILABLE = False

# See: https://mimesniff.spec.whatwg.org/
# Buffer size should be >= 1445 for deterministic results in most cases
# Most documentation uses 2048 to slightly exceed this requirement
# If the data is smaller than 2048 just use the entire thing
MIME_DETECTION_BUFFER_SIZE = 2048


class ContentArgs(TypedDict):
    extension: str | None
    mimetype: str | None
    filename: str | None
    path: str | None
    size: int | None
    encoding: str | None
    extra: dict[str, Any]


# use discriminated unions instead of typedict
class ContentKeywordArgs(TypedDict, total=False):
    extension: str
    mimetype: str
    filename: str
    path: str
    size: int
    encoding: str
    extra: dict[str, Any]


def is_valid_path(input: str | Path) -> bool:
    if isinstance(input, str):
        input = Path(input)
    try:
        return input.exists() and input.is_file()
    except Exception as _:
        return False


def default_filename(
    extension: str,
) -> str:
    now = datetime.now()
    datetime_str = now.strftime("%Y%m%d_%H%M%S")
    # Do not give the file an empty extension. Prefer none
    if len(extension) == 0:
        return datetime_str

    return datetime_str + "." + extension


def get_extension_from_mimetype(mimetype: str) -> str:
    extension = mimetypes.guess_extension(mimetype)
    if not extension:
        raise ValueError(
            f"Got mime-type {mimetype} but failed to resolve a valid extension"
        )
    return extension.lstrip(".")


def guess_from_buffer(buffer: bytes) -> str | None:
    if not MAGIC_LIB_AVAILABLE:
        return None

    match = puremagic.magic_stream(BytesIO(buffer))[0]
    return match.mime_type


def guess_from_filename(filename: str) -> str | None:
    return mimetypes.guess_type(filename)[0]


def guess_from_extension(extension: str) -> str | None:
    filename = f"file.{extension.lstrip('.')}"
    return guess_from_filename(filename)


def guess_from_path(path: str | Path) -> str | None:
    path = Path(path)
    mimetype = guess_from_filename(path.name)
    return mimetype


def get_mime_and_extension(
    *,
    mimetype: str | None,
    extension: str | None,
    filename: str | None,
    buffer: bytes | None,
) -> tuple[str, str]:
    if mimetype and extension:
        return mimetype, extension
    elif mimetype and not extension:
        return mimetype, get_extension_from_mimetype(mimetype)

    if filename is not None:
        mimetype = guess_from_filename(filename)
    if not mimetype and extension is not None:
        mimetype = guess_from_extension(extension)
    if not mimetype and buffer is not None:
        mimetype = guess_from_buffer(buffer[:MIME_DETECTION_BUFFER_SIZE])

    if mimetype and extension:
        return mimetype, extension
    elif mimetype and not extension:
        return mimetype, get_extension_from_mimetype(mimetype)
    elif not MAGIC_LIB_AVAILABLE:
        logger.warning(
            "Failed to determine MIME type from file extension and cannot infer from data\n"
            "MIME type detection from raw data requires the puremagic library\n"
            "Install it by running: `pip install puremagic`\n"
            "See: https://pypi.org/project/puremagic for detailed instructions"
        )
    if filename is not None:
        idx = filename.rfind(".")
        if idx != -1:
            extension = filename[idx:]

    return "application/octet-stream", ""
```

Here are the contents of `content_types.py`:
```python
from __future__ import annotations

from pathlib import Path
from typing import Annotated, Literal, TypedDict, Union

from pydantic import Field

MetadataKeysType = str | int
MetadataValueType = MetadataKeysType | list["MetadataValueType"] | dict[MetadataKeysType, "MetadataValueType"]
MetadataType = dict[MetadataKeysType, "MetadataValueType"]

ContentType = Literal['bytes', 'text', 'base64', 'file', 'url']

# These represent the args the user can pass in to create various types of content
# Optional args that can be passed to any content
class BaseContentArgs(TypedDict):
    mimetype: str | None
    metadata: MetadataType | None

class BytesContentArgs(BaseContentArgs):
    data: bytes
    encoding: str | None
    content_type: Literal['bytes']

class TextContentArgs(BaseContentArgs):
    text: str
    encoding: str | None
    content_type: Literal['text']

class FileContentArgs(BaseContentArgs):
    path: str | Path
    encoding: str | None
    content_type: Literal['file']

class Base64ContentArgs(BaseContentArgs):
    b64_data: str | bytes
    content_type: Literal['base64']

class UrlContentArgs(BaseContentArgs):
    url: str
    headers: dict
    content_type: Literal['url']

ContentArgs = Annotated[
    Union[
        BytesContentArgs,
        TextContentArgs,
        FileContentArgs,
        Base64ContentArgs,
        UrlContentArgs
    ],
    Field(discriminator='content_type')
]

class ResolvedContentArgs(TypedDict):
    # Required Fields
    id: str
    data: bytes
    size: int
    mimetype: str
    digest: str
    filename: str # Computed
    content_type: ContentType
    input_type: str # computed

    # Optional Fields
    extra: MetadataKeysType | None # Passed in
    path: str | None
    extension: str | None
    encoding: str | None
```

Here is some starer code for `content.py`
```
from typing import Annotated
from typing_extensions import Unpack
from pydantic import Field, BaseModel
from utils import (
    get_mime_and_extension
)
from content_types import (
    ContentType,
    MetadataType,
    ContentArgs,
    Base64ContentArgs,
    BytesContentArgs,
    FileContentArgs,
    TextContentArgs,
    ResolvedContentArgs
)

class BaseContentHandler(BaseModel):
    id: str
    data: bytes
    size: int
    mimetype: str
    digest: str
    filename: str # Computed
    content_type: ContentType
    input_type: str # computed

    extra: Annotated[MetadataType, Field(
        description="Extra metadata to associate with the content",
        examples=[{"number of cats": 1}]
    )] = {}
    encoding: str = "utf-8"
    path: str | None = None
    extension: str | None = None

# Implement the Content class here
```
