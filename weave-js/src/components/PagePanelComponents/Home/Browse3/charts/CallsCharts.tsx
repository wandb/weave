import {GridFilterModel, GridSortDirection} from '@mui/x-data-grid-pro';
import {MOON_50} from '@wandb/weave/common/css/color.styles';
import React from 'react';

import {Button} from '../../../../../components/Button';
import {WFHighLevelCallFilter} from '../pages/CallsPage/callsTableFilter';
import {useCallsForQuery} from '../pages/CallsPage/callsTableQuery';
import {Chart} from './Chart';
import {ChartModal} from './ChartModal';
import {
  ChartsProvider,
  useChartsDispatch,
  useChartsState,
} from './ChartsContext';
import {ChartTypeSelectionDrawer} from './ChartTypeSelectionDrawer';
import {chartAxisFields, extractCallData} from './extractData';
import {ChartConfig} from './types';

type CallsChartsProps = {
  entity: string;
  project: string;
  filterModelProp: GridFilterModel;
  filter: WFHighLevelCallFilter;
};

const CallsChartsInner = ({
  entity,
  project,
  filter,
  filterModelProp,
}: CallsChartsProps) => {
  const [pageSize, setPageSize] = React.useState(250);
  const [isDropdownOpen, setIsDropdownOpen] = React.useState(false);
  const dropdownRef = React.useRef<HTMLDivElement>(null);

  const pageSizeOptions = React.useMemo(
    () => [
      {value: 10, label: '10'},
      {value: 25, label: '25'},
      {value: 50, label: '50'},
      {value: 100, label: '100'},
      {value: 250, label: '250'},
      {value: 500, label: '500'},
      {value: 1000, label: '1000'},
    ],
    []
  );

  // Close dropdown when clicking outside
  React.useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node)
      ) {
        setIsDropdownOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const handlePageSizeSelect = (option: {value: number; label: string}) => {
    setPageSize(option.value);
    setIsDropdownOpen(false);
  };

  const columns = React.useMemo(
    () => [
      'display_name',
      'started_at',
      'ended_at',
      'exception',
      'id',
      'inputs',
      'output',
    ],
    []
  );
  const columnSet = React.useMemo(() => new Set(columns), [columns]);
  const sortCalls = React.useMemo(
    () => [{field: 'started_at', sort: 'desc' as GridSortDirection}],
    []
  );
  const page = React.useMemo(
    () => ({
      pageSize,
      page: 0,
    }),
    [pageSize]
  );

  // Single query: Get all calls for the current filter
  const calls = useCallsForQuery(
    entity,
    project,
    filter,
    filterModelProp,
    page,
    sortCalls,
    columnSet,
    columns
  );

  // Process call data
  const callData = React.useMemo(() => {
    return extractCallData(calls.result || []);
  }, [calls.result]);

  const isLoading = calls.loading || calls.costsLoading;
  const {charts} = useChartsState();
  const dispatch = useChartsDispatch();

  const [typeSelectionDrawerOpen, setTypeSelectionDrawerOpen] =
    React.useState(false);
  const [pendingChartTypeSelection, setPendingChartTypeSelection] =
    React.useState<'scatter' | 'line' | 'bar' | null>(null);
  const [modalState, setModalState] = React.useState<
    | {open: false}
    | {
        open: true;
        mode: 'edit';
        initialConfig: Partial<ChartConfig>;
        editId: string;
      }
  >({open: false});

  const defaultConfig = React.useMemo(
    () => ({
      xAxis: chartAxisFields[0]?.key || 'started_at',
      yAxis: chartAxisFields.find(f => f.type === 'number')?.key || 'latency',
      plotType: 'scatter' as const,
      binCount: 20,
      aggregation: 'average' as const,
    }),
    []
  );

  const openTypeSelectionDrawer = () => {
    setTypeSelectionDrawerOpen(true);
  };

  const closeTypeSelectionDrawer = () => {
    setTypeSelectionDrawerOpen(false);
  };

  const handleChartTypeSelection = (plotType: 'scatter' | 'line' | 'bar') => {
    // Create chart with default config and selected plot type
    const newChartConfig = {
      ...defaultConfig,
      plotType,
    };

    // Set pending chart type to track when to open modal
    setPendingChartTypeSelection(plotType);

    // Add the chart (ID will be generated by the reducer)
    dispatch({
      type: 'ADD_CHART',
      payload: newChartConfig,
    });

    // Close the drawer
    closeTypeSelectionDrawer();
  };

  const openEditModal = (id: string) => {
    const chart = charts.find(c => c.id === id);
    if (chart) {
      setModalState({
        open: true,
        mode: 'edit',
        initialConfig: {...chart},
        editId: id,
      });
    }
  };

  const closeModal = () => {
    setModalState({open: false});
  };

  const handleConfirm = (config: Partial<ChartConfig>) => {
    if (modalState.open && modalState.mode === 'edit' && modalState.editId) {
      dispatch({type: 'UPDATE_CHART', id: modalState.editId, payload: config});
    }
    closeModal();
  };

  // Track previous chart IDs to detect new charts
  const prevChartIdsRef = React.useRef(new Set(charts.map(c => c.id)));

  // Watch for new charts being added and open modal if we're expecting one
  React.useEffect(() => {
    if (pendingChartTypeSelection && charts.length > 0) {
      // Find charts that weren't in the previous state
      const newCharts = charts.filter(
        chart => !prevChartIdsRef.current.has(chart.id)
      );

      // Find the new chart with the pending plot type
      const newChart = newCharts.find(
        chart => chart.plotType === pendingChartTypeSelection
      );

      if (newChart) {
        // Clear pending state
        setPendingChartTypeSelection(null);

        // Open modal for the new chart
        setModalState({
          open: true,
          mode: 'edit',
          initialConfig: {...newChart},
          editId: newChart.id,
        });
      }
    }

    // Update previous chart IDs
    prevChartIdsRef.current = new Set(charts.map(c => c.id));
  }, [charts, pendingChartTypeSelection]);

  return (
    <>
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          height: '100%',
          width: '100%',
          position: 'relative',
        }}>
        {/* Header */}
        <div
          style={{
            backgroundColor: MOON_50,
            borderBottom: '1px solid rgba(224, 224, 224, 1)',
            padding: '7px 16px 7px 16px',
            boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)',
            flexShrink: 0,
          }}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
            }}>
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: '8px',
              }}>
              <span
                style={{
                  fontSize: '14px',
                  fontWeight: 500,
                  color: '#79808A',
                }}>
                Charts showing data for
              </span>
              <div style={{position: 'relative'}} ref={dropdownRef}>
                <span
                  style={{
                    fontSize: '14px',
                    fontWeight: 'bold',
                    color: '#79808A',
                    cursor: 'pointer',
                    transition: 'color 0.2s ease',
                  }}
                  onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                  onMouseEnter={e => (e.currentTarget.style.color = '#038194')}
                  onMouseLeave={e => (e.currentTarget.style.color = '#79808A')}>
                  {pageSize}
                </span>
                {isDropdownOpen && (
                  <div
                    style={{
                      position: 'absolute',
                      top: '100%',
                      left: 0,
                      zIndex: 1001,
                      marginTop: 4,
                      minWidth: 80,
                      backgroundColor: 'white',
                      border: '1px solid #e0e0e0',
                      borderRadius: '6px',
                      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
                      padding: '4px 0',
                    }}>
                    {pageSizeOptions.map(option => (
                      <div
                        key={option.value}
                        style={{
                          padding: '8px 12px',
                          cursor: 'pointer',
                          fontSize: '14px',
                          backgroundColor:
                            pageSize === option.value
                              ? '#f0f9ff'
                              : 'transparent',
                          color:
                            pageSize === option.value ? '#0891b2' : '#374151',
                        }}
                        onMouseEnter={e => {
                          if (pageSize !== option.value) {
                            e.currentTarget.style.backgroundColor = '#f9fafb';
                          }
                        }}
                        onMouseLeave={e => {
                          if (pageSize !== option.value) {
                            e.currentTarget.style.backgroundColor =
                              'transparent';
                          }
                        }}
                        onClick={() => handlePageSizeSelect(option)}>
                        {option.label}
                      </div>
                    ))}
                  </div>
                )}
              </div>
              <span
                style={{
                  fontSize: '14px',
                  fontWeight: 500,
                  color: '#79808A',
                }}>
                calls
              </span>
            </div>
            <Button
              icon="add-new"
              variant="ghost"
              size="small"
              onClick={openTypeSelectionDrawer}>
              Add Chart
            </Button>
          </div>
        </div>

        {/* Scrollable charts container */}
        <div
          style={{
            display: 'flex',
            flexDirection: 'column',
            gap: 12,
            overflowX: 'hidden',
            overflowY: 'auto',
            padding: '12px',
            flex: 1,
            minHeight: 0,
          }}>
          {charts.length === 0 ? (
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: '#8F8F8F',
                fontSize: 14,
                width: '100%',
                minHeight: 200,
                textAlign: 'center',
                padding: '40px 20px',
              }}>
              No charts available. Click "Add Chart" to create one.
            </div>
          ) : (
            charts.map(chart => {
              const yField = chartAxisFields.find(f => f.key === chart.yAxis);
              const baseTitle = yField ? yField.label : chart.yAxis;
              const chartTitle = baseTitle;
              return (
                <Chart
                  key={chart.id}
                  data={callData}
                  height={260}
                  xAxis={chart.xAxis}
                  yAxis={chart.yAxis}
                  plotType={chart.plotType || 'scatter'}
                  binCount={chart.binCount}
                  aggregation={chart.aggregation}
                  title={chartTitle}
                  chartId={chart.id}
                  entity={entity}
                  project={project}
                  colorGroupKey={chart.colorGroupKey}
                  isLoading={isLoading}
                  onEdit={() => openEditModal(chart.id)}
                  onRemove={() =>
                    dispatch({type: 'REMOVE_CHART', id: chart.id})
                  }
                  filter={filter}
                />
              );
            })
          )}
        </div>

        <ChartTypeSelectionDrawer
          open={typeSelectionDrawerOpen}
          onClose={closeTypeSelectionDrawer}
          onSelectType={handleChartTypeSelection}
        />

        {modalState.open && (
          <ChartModal
            open={modalState.open}
            mode="edit"
            initialConfig={modalState.initialConfig}
            onClose={closeModal}
            onConfirm={handleConfirm}
            callData={callData}
            entity={entity}
            project={project}
          />
        )}
      </div>
    </>
  );
};

export const CallsCharts = (props: CallsChartsProps) => (
  <ChartsProvider entity={props.entity} project={props.project}>
    <CallsChartsInner {...props} />
  </ChartsProvider>
);
